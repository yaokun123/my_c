//
// Created by 姚坤 on 2022/1/28.
//


//// 消息队列可认为是一个消息链表，有足够写权限的线程可往队列中放置消息，有足够读权限的线程可从队列中取走消息。
//// 每个消息都是一个记录，它由发送者赋予一个优先级
//// 在某个进程往队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。这跟管道和FIFO是相反的。
//// 管道和FIFO，除非读出者已存在，否则线有写入者是没有意义的。

//// 随内核的持续性：一个进程可以往某个队列写入一些消息，然后终止，再让另外一个进程在以后某个时刻读出这些消息。
//// 这跟管道和FIFO不一样，当一个管道或FIFO的最后一次关闭发生时，仍在该管道或FIFO上的数据将被丢弃。

//// Posix与System V主要区别：
// 1、对Posix消息队列的读总是返回最高优先级的最早消息，对System V消息队列的读则可以返回任意指定优先级的消息。
// 2、当往一个空队列放置一个消息时，Posix消息队列允许产生一个信号或启动一个线程，System V消息队列则不提供类似机制。


//// 队列中每个消息具有如下属性
// 1、一个无符号整数优先级(Posix)或一个长整数类型(System V)
// 2、消息的数据部分长度可以为0
// 3、数据本身


//// 相关函数
// 1、mq_open函数创建一个新的消息队列或打开一个已存在的消息队列。

// 2、mq_close功能与关闭一个已打开文件的close函数类似：调用进程可以不再使用该描述符，但其消息队列并不从系统中删除。
// 一个进程终止时，他的所有打开着的消息队列都关闭，就像调用了mq_close一样。

// 3、mq_unlink要从系统中删除mq_open的第一个参数的某个name，必须要调用mq_unlink。
// 每个消息队列有一个保存其当前打开着描述符数的引用计数器（就想文件一样），因而本函数能够实现类似于unlink函数删除一个文件的机制。
// 当一个消息队列的引用计数为0时候，其name删除，该队列也释放。
// 当一个消息队列的引用计数仍大于0时，其name也能删除，但是该队列的析构要到最后一个mq_close发生是才进行。

// 4、mq_getattr
// 每个消息队列有四个属性，mq_getattr返回所有这些属性

// 5、mq_setattr
// 每个消息队列有四个属性，mq_setattr设置其中某个属性

// 6、mq_send
// 从队列中放置一个消息，每个消息有一个优先级，他是一个小于MQ_PRIO_MAX的无符号整数，Posix要求这个上限至少32。

// 7、mq_receive
// 从队列中取走一个消息，返回指定队列中最高优先级的最早消息，而且该优先级能随该消息的内容及长度一同返回。



//// 消息队列限制
// 1、mq_mqxmsg队列中的最大消息数
// 2、mq_msgsize给定消息的最大字节数
// 3、MQ_OPEN_MAX一个进程能够同时拥有的打开着消息队列的最大数目
// 4、MQ_PRIO_MAX任意消息的最大优先值+1


//// 异步事件通知
// system V消息队列的问题之一是无法通知一个进程何时在某个队列中放置了一个消息。
// Posix消息队列允许异步事件通知，以告知何时有一个消息放置到了某个空消息队列中。两种方式：
// 1、产生一个信号
// 2、创建一个线程来执行一个指定函数

#include <mqueue.h>























